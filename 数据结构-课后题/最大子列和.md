7-1 最大子列和问题 (20 分)

给定*K*个整数组成的序列{ *N*1, *N*2, ..., *N**K* }，“连续子列”被定义为{ *N**i*, *N**i*+1, ..., *N**j* }，其中 1≤*i*≤*j*≤*K*。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。

本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：

- 数据1：与样例等价，测试基本正确性；
- 数据2：10^2个随机整数；
- 数据3：10^3个随机整数；
- 数据4：10^4个随机整数；
- 数据5：10^5个随机整数；

### 输入格式:

输入第1行给出正整数*K* (≤100000)；第2行给出*K*个整数，其间以空格分隔。

### 输出格式:

在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。

### 输入样例:

```in
6
-2 11 -4 13 -5 -2
```

### 输出样例:

```out
20
```



解答：

本题是MOOC数据结构课程的第一题，主要考察不同算法在不同规模数据输入下的性能表现。以及代码输入输出的规范化。

解法1

最简单，最容易想到的，也是最暴力的解决方法就是一层层遍历:

```c
//如果所有整数都为负数，则输出0
MaxSum = 0;
for(i=0;i<array.size();i++)
{
    for(j=i;j<array.size();j++)
    {
        for(k=i;k<j;k++)
        	temp += array[k];
        if(temp>MaxSum)
            MaxSum = temp;
    }
}
```

这里能看出来算法的时间~~效率~~复杂度是O(n^3)

解法2

主要是针对解法1的优化，起始下标固定后，后面不断移动末端下标计算子列和，实际上第三层循环每次都会重复计算前面计算的结果。

```c
MaxSum = 0;
for(i=0;i<array.size();i++)
{
    temp = 0;
    for(j=i;j<array.size();j++)
    {
        temp += array[j];
        if(temp>MaxSum)
            MaxSum = temp;
    }
}
```

可以看出来算法的时间~~效率~~复杂度是O(n^2)

解法3

分而治之，概念上很好理解。其实我现在回过头想想，这个算法可能只有写出来了才会觉得效率会比上面的高，老师的一个提议是当碰到一个O(n^2)的算法，要自然而然的想想有没有可能降为nlogn。

```c
//1.如果队列只有一个元素，则该元素即为最大子列和
//	1.1如果队列不止一个元素，则找到队列的一半位置，将队列分成左右两份
//	1.2计算左边的最大子列和 go to 1.1
//	1.3计算右边的最大子列和 go to 1.1
//	1.4计算中间的最大子列和 先往左边计算最大子列和，再往右边计算最大子列和，合并即为中间的最大子列和
//5.得到最大子列和
//可以看出来该算法是通过以空间换时间效率。

```



解法4

在线处理，老师提过一嘴，该算法正确性不那么高，但我起始也没明白该算法为什么正确，所以也不知道如何讨论它的正确性。先放一放了。

```c
//从队列起始位置开始累加
//每次加的和都与初始值为0的临时变量比较
//如果大于临时变量，则更新临时变量值
//如果加出来的和为非正数，则舍弃该子串，从下一个位置重新开始加
```

